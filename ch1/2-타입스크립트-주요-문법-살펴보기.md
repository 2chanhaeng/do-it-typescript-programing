# 타입스크립트 주요 문법 살펴보기

- [타입스크립트 주요 문법 살펴보기](#타입스크립트-주요-문법-살펴보기)
  - [ESNext 주요 문법](#esnext-주요-문법)
    - [구조 분해 할당](#구조-분해-할당)
    - [화살표 함수](#화살표-함수)
    - [클래스](#클래스)
      - [상속](#상속)
      - [캡슐화](#캡슐화)
      - [다형성과 추상화](#다형성과-추상화)
    - [모듈](#모듈)
    - [반복 프로토콜 (Iteration Protocol)](#반복-프로토콜-iteration-protocol)
      - [반복자 프로토콜 (Iterator Protocol)](#반복자-프로토콜-iterator-protocol)
    - [Promise, async/await](#promise-asyncawait)
  - [참조](#참조)

## ESNext 주요 문법

### 구조 분해 할당

```typescript
const amy = {
  name: 'Amy',
  age: 20,
};
const { name, age } = amy;
console.log(name, age); // Amy 20

let array = [1, 2, 3, 4];
let [head, ...rest] = array;
console.log(head, rest); // 1 [2, 3, 4]

let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b); // 2 1
```

파이썬도 `*` 연산자를 비슷하게 사용할 수 있다.  
파이썬은 `*` 후에도 다른 변수를 할당할 수 있지만, 아쉽게도 JS는 `...` 를 사용한 이후에는 할당할 수 없다.

```python
a, *b, c = [1, 2, 3, 4, 5]
print(a, b, c) # 1 [2, 3, 4] 5
```

```typescript
let [a, ...b, c] = [1, 2, 3, 4, 5]; // Uncaught SyntaxError: rest element may not have a trailing comma
```

### 화살표 함수

```typescript
function declaratedAdd(a: number, b: number): number {
  return a + b;
}
const arrowedAdd = (a: number, b: number): number => a + b;
```

기존의 `function` 키워드를 이용한 함수 선언/표현식 방식과 달리, 화살표 함수는 `this` 바인딩이 다르다.

```typescript
const doctor = {
  name: 'Doctor',
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  },
  sayHiArrow: () => {
    console.log(`Hi, I'm ${this.name}.`);
  },
};
doctor.sayHi(); // Hi, I'm Doctor.
doctor.sayHiArrow(); // Hi, I'm .
```

런타임이 브라우저 환경이고 strict mode가 아닌 경우, 전역 `this`는 `window` 객체를 가리킨다.  
이 때 `sayHi`는 `this`가 `person`으로 바인딩된다.  
하지만 `sayHiArrow`는 `this`가 바인딩 되지 않는다.  
그러므로 `this`를 참조할 경우 상위 스코프인 전역 객체 `window`를 참조하게 된다.

```typescript
let clara = {
  name: 'Clara',
  sayHi: doctor.sayHi,
  sayHiArrow: doctor.sayHiArrow,
  sayHiArrowInFunction() {
    console.log(`Hi, I'm ${this.name}.`);
    (() => console.log(`Hi, I'm ${this.name}.`))();
  }
};
clara.sayHi(); // Hi, I'm Clara.
clara.sayHiArrow(); // Hi, I'm .
clara.sayHiArrowInFunction();
```

JS에서 `Function` 객체를 `call` 메소드를 통해 호출하면 다음과 같다.

```javascript
function sayHi(hi, im) {
  console.log(`${hi}, ${im} ${this}.`);
}
sayHi.call("Clara", "Hi", "I'm"); // Hi, I'm Clara.
```

`call` 메소드는 첫 번째 인자로 `thisValue`를, 그 이후의 인자로 함수 호출 시의 인자를 받는다.  
`call` 메소드를 사용하지 않고 일반적인 방법으로 함수를 호출하면 `this`는 전역 객체를 참조한다.

```javascript
sayHi("Hi", "I'm"); // Hi, I'm [object Window].
```

`call` 메소드를 사용하지 않고 `this`를 바인딩하려면 `bind` 메소드를 사용한다.  
`bind` 메소드는 `thisValue`를 바인딩한 새로운 함수를 반환한다.

```javascript
const sayHiClara = sayHi.bind("Clara");
sayHiClara("Hi", "I'm"); // Hi, I'm Clara.
```

만약 객체의 메소드를 `bind` 메소드를 통해 바인딩하면, `this`는 바인딩된 객체를 참조한다.

```javascript
const sayHiClara = sayHi.bind(clara);
sayHiClara("Hi", "I'm"); // Hi, I'm Clara.
```

이를 통해 함수 표현식과 화살표 함수를 이용한 메소드 선언 시 `this` 바인딩의 차이를 이해할 수 있다.  
함수 표현식으로 메소드를 선언하면 메소드에 객체를 바인딩한 함수를 할당한 것과 같다.
화살표 함수으로 메소드를 선언하면

```javascript
function sayHi() {
  console.log(`Hi, I'm ${this.name}.`);
}

const rose = {
  name: 'Rose',
  sayHi: sayHi, // 자동으로 객체를 바인딩 해준다.
  sayHiArrow: sayHi.bind(this), // 현재 스코프의 this, 즉 현재 맥락의 rose가 아닌 전역 this를 바인딩한다.
};
// 혹은 다음과 같다.
const rose = { name: 'Rose' };
rose.sayHi = sayHi.bind(rose);
rose.sayHiArrow = sayHi.bind(this);
```

다음과 같은 코드를 실행하면 더 확실히 이해할 수 있다.

```typescript
const outer = {
    name: "outer",
    sayHi: function() {
        const inner = {
            name: "inner",
            sayHiFuncExp: function() {
                console.log(`Hi, I'm ${this.name}.`);
            },
            sayHiNotBinded: sayHi,
            sayHiArrow: () => console.log(`Hi, I'm ${this.name}.`),
            sayHiBinded: sayHi.bind(this),
        };
        console.log("Function Expression & Not Binded: this is inner");
        inner.sayHiFuncExp(); // Hi, I'm inner.
        inner.sayHiNotBinded(); // Hi, I'm inner.
        console.log("Arrow Function & Binded: this is outer");
        inner.sayHiArrow(); // Hi, I'm outer.
        inner.sayHiBinded(); // Hi, I'm outer.
    },
}
outer.sayHi();
```

`sayHiFuncExp`, `sayHiNotBinded`는 `this`에 `inner` 객체가 바인딩된다.  
`sayHiArrow`, `sayHiBinded`는 `this`에 `outer` 객체가 바인딩된다.

### 클래스

많은 객체 지향 언어에서 사용되는 클래스 문법이 ES6에서 도입되었다.

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  }
}
const yaz = new Person('Yaz', 20);
```

이를 ES5에서도 호환 가능한 다음과 같은 코드로도 작성할 수 있다.

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHi = function() {
    console.log(`Hi, I'm ${this.name}.`);
  }
  return this;
}

const yaz = new Person('Yaz', 20);
```

`new` 연산자는 클래스의 인스턴스를 생성한다.  
만약 해당 코드에서 `new` 연산자가 없다면 `this`는 전역 객체를 참조한다.

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHi = function() {
    console.log(this);
    console.log(`Hi, I'm ${this.name}.`);
  }
  return this;
}

const withoutNewYaz = Person('Yaz', 20);
withoutNewYaz.sayHi();
// Window
// Hi, I'm Yaz.
const yaz = new Person('Yaz', 20);
yaz.sayHi();
// Person {name: "Yaz", age: 20, sayHi: ƒ}
// Hi, I'm Yaz.
```

클래스 문법을 사용해서 인스턴스를 생성할 때 `new` 연산자가 없다면, 런타임이 이를 막기 때문에 클래스의 인스턴스를 생성할 수 없다.

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  }
}
const yaz = new Person('Yaz');
// Person { name: 'Yaz', sayHi: [Function: sayHi] }
const withoutNewYaz = Person('Yaz');
// Uncaught TypeError: class constructors must be invoked with 'new'
```

이제 객체지향 패러다임의 주 특성인 상속, 캡슐화, 다형성, 추상화를 어떻게 구현하는지 알아보자

#### 상속

JS는 `extends` 키워드를 통해 상속을 구현할 수 있다.  
상속을 받는 자손 클래스에서는 `super` 키워드를 통해 부모 클래스의 생성자를 호출할 수 있다.

```javascript
class Companion extends Person {
    constructor(name, end) {
        super(name);
        this.end = end;
    }
    endWith() {
        console.log(`${this.name} ${this.end}.`);
    }
}

const bill = new Companion('Bill', 'became a Cyberman');
bill.sayHi(); // Hi, I'm Bill.
bill.endWith(); // Bill became a Cyberman.
```

자손 클래스의 생성자에서 `super` 키워드를 호출하지 않으면 부모 클래스의 생성자가 호출되지 않는다.  
이로 인해 `this`가 초기화되지 않아 인스턴스 생성 시 오류가 발생한다.

```javascript
class Companion extends Person {
    constructor(name, end) {
        this.end = end;
    }
}

const bill = new Companion('Bill', 'became a Cyberman');
// Uncaught ReferenceError: must call super constructor before using 'this' in derived class constructor
```

#### 캡슐화

데이터의 직접적인 접근을 막고 메소드를 통한 간접적인 접근을 통해 데이터를 조작하도록 만들어 안전성을 높이는 것이다.  
ESNext에서는 인스턴스 혹은 클래스 변수의 이름에 `#`을 붙여 직접적인 접근을 막는 private field를 지원한다.

```javascript
class Person {
    #name; // private field는 사전에 선언하지 않으면 SyntaxError 가 발생한다.
    constructor(name) {
        this.#name = name;
    }
    sayHi() {
        console.log(`Hi, I'm ${this.#name}.`); // 클래스 내부에서는 private field에 얼마든지 접근할 수 있다.
    }
}

const martha = new Person('Martha');
martha.sayHi(); // Hi, I'm Martha.
martha.#name; // Uncaught SyntaxError: reference to undeclared private field or method #name
```

하지만 외부에서 private field에 접근이 필요한 경우도 있을 것이다.  
JS의 클래스는 요소에 간접적으로 접근하는 getter와 setter를 정의할 수 있다.  
이를 통해 private field를 외부에서도 안전하게 저장하고 노출시킬 수 있다.

```javascript
class Person {
    #name;
    constructor(name) {
        this.#name = name;
    }
    get name() {
        return this.#name;
    }
    set name(name) {
        this.#name = name;
    }
    sayHi() {
        console.log(`Hi, I'm ${this.#name}.`);
    }
}

const donna = new Person('Donna');
donna.sayHi(); // Hi, I'm Donna.
donna.name = 'Doctor Donna';
donna.sayHi(); // Hi, I'm Doctor Donna.
donna.name = 'Donna';
console.log(donna.name); // Donna
```

#### 다형성과 추상화

JS에서 다형성은 상속과 오버로딩을 통해 구현할 수 있으므로 따로 다루지 않겠다.

일반적으로 객체지향 프로그래밍이 가능한 언어라면 추상화를 위해 인터페이스나 추상 클래스를 지원한다.  
지만 JS는 이를 지원하지 않는다.  
이를 해결하기 위해 TS는 인터페이스를 지원하지만 지금은 ESNext 내용이므로 추후 다루도록 하겠다.

### 모듈

`import`, `export` 키워드를 통해 모듈을 불러올 수 있다.  
다만 약간의 설정이 필요하다.

1. 브라우저 환경: `script` 태그에 `type="module"` 속성을 추가한다.
2. Node.js 환경: `package.json` 파일에 `"type": "module"` 속성을 추가한다.

```javascript
// export.js
export function sayHi() {
  console.log('Hi!');
}
```

```javascript
// import.js
import { sayHi } from '<import할 파일의 디렉토리>/export.js';
sayHi(); // Hi!
```

이때 `import` 문은 항상 파일의 최상단에 위치해야 한다.
여기서 최상단이란 임의의 클로저나 조건문, 반복문 등의 블록 내부가 아닌 파일의 가장 바깥쪽을 의미한다.

```javascript
// import.js
if (true) {
  import { sayHi } from '<import할 파일의 디렉토리>/export.js';
  // Uncaught SyntaxError: Cannot use import statement inside a module
}
```

`as` 키워드를 이용하면 원하는 이름으로 변수를 선언할 수 있다.

```javascript
// import.js
import { sayHi as hi } from '<import할 파일의 디렉토리>/export.js';
hi(); // Hi!
```

`*` 를 이용해 모듈을 통채로 객체처럼 사용할 수 있다.

```javascript
// import.js
import * as exportModule from '<import할 파일의 디렉토리>/export.js';
exportModule.sayHi(); // Hi!
```

`export default` 키워드를 사용하면 좀더 편리하게 사용할 수 있다.
먼저 모듈 내에서 변수 이름을 짓지 않아도 된다.(물론 지어서 내보내도 무방하다.)
또한 `import` 문에서 중괄호 없이 받을 수 있고, 원하는 이름으로 변수를 선언할 수 있다.
다만 기본으로 내보내는 변수를 받을 때는 중괄호 외부에서 선언하거나, `as` 키워드를 사용해야 한다.

```javascript
// export.js
export default function() {
  console.log('Hi!');
}
```

```javascript
// import.js
import sayHi from 'export_module';
import { default as sayHello } from 'export_module';
```

단, `default` 키워드는 한 모듈에서 한 번만 사용할 수 있다.

```javascript
// export.js
export default function sayHi() {
  console.log('Hi!');
}
export default function sayHello() {
  console.log('Hello!');
}
// Uncaught SyntaxError: Duplicate export 'default'
```

`export` 문에 `from` 을 사용하면 다른 모듈에서 내보낸 것을 그대로 내보낼 수 있다.

```javascript
// export_from.js
// 기본적으로 import와 동일하게 사용할 수 있다.
export {
    sayHi,
    sayBye as sayGoodbye,
    default as sayHello, // 다만 기본으로 내보내는 변수를 받을 때는 중괄호 외부에서는 불가능하고 무조건 as 키워드를 사용해야 한다.
} from 'export_module';
export sayGoodbye from 'export_default'; // 불가능. 무조건 { default as <변수 이름> } 구문을 사용해야한다.
export * from 'export_all';
export { default } from 'export_default_as_default'; // 기본을 받아 그대로 기본으로 내보낼 수 있다.
```

`export from` 문을 사용할 경우 내부에서 사용할 수 없다.  
내부에서 사용하고 내보내야할 경우 `import` 문을 사용해서 받아온 뒤 `export` 문으로 따로 내보내야 한다.

```javascript
// 올바른 사용법
import { sayHi } from 'export.js';
sayHi(); // Hi!
export { sayHi };
// 에러
export { sayHi } from 'export.js';
sayHi(); // Uncaught ReferenceError: sayHi is not defined
```

웬만하면 굳이 또 내보내지 말고 기존에 받아온 모듈에서 받아오는 식으로 쓰는 것이 더 보기 좋다고 개인적으로 생각한다.  
물론 내부에서 값을 변환한 후에 내보내거나, 세트로 같이 사용하는 경우가 많은 경우 등에서는 받아온 것을 다시 내보내는 것도 나쁘지 않다고 생각한다.  
다만 전자의 경우는 새로운 변수에 값을 할당하는 것이, 후자는 하나의 객체나 클래스로 묶어서 내보내는 것이 더 좋다고 생각한다.

### 반복 프로토콜 (Iteration Protocol)

반복 프로토콜은 반복 가능한 객체를 만들기 위한 규약이다.  
반복 프로토콜을 따르는 객체는 `for of`, `...`(spread operator) 등 반복적인 동작을 수행할 수 있다.  
예를 들어서 다음과 같은 코드를 보자.

```javascript
function genIterable(){
  return {
    [Symbol.iterator]() {
      return {
        arr: [],
        next() {
          return this.arr.length < 5
            ? { value: this.arr.push(this.arr.length), done: false }
            : { value: undefined, done: true }
        }
      }
    }
  }
}

for (const i of genIterable()) {
  console.log(i);
}
// 1 -> 2 -> 3 -> 4 -> 5
console.log([...genIterable()]); // [1, 2, 3, 4, 5]
```

`genIterable` 함수에서 반환된 객체는 `Array` 나 `String` 객체도 아니지만 `for of` 문과 `...` 연산자를 통해 반복적인 동작을 수행할 수 있다.  
이는 해당 객체가 반복 프로토콜을 따르기 때문이다.  
또한 `Array` 나 `String` 같은 객체도 반복 프로토콜을 따르기 때문에 반복적인 동작을 수행할 수 있는 것이다.

#### 반복자 프로토콜 (Iterator Protocol)

반복자 프로토콜은 특정한 값들의 배열(Sequence)를 만들기 위한 규약이다.  
반복자 프로토콜을 따르는 객체를 반복자라고 한다.  
반복자는 먼저 `next` 메소드를 가지고 있어야 한다.  
또한 이 메소드는 `{ value: any, done: boolean }` 형태의 객체를 반환해야 한다.

반대로 말하면 먼저 `value: any`와 `done: boolean` 속성을 가진 객체를 반환하는 함수를 가정하자.  
그리고 이런 함수를 `next` 라는 이름의 메소드로 정의된 객체를 가정하자.  
그렇다면 이 객체는 반복자라고 할 수 있다.  
조금 스포(?)해서 TS를 이용해 인터페이스를 구현하면 다음과 같다.

```typescript
interface Iterator {
  next(): { value: any, done: boolean };
}
```


### Promise, async/await

## 참조

- [MDN](https://developer.mozilla.org/ko)
  - [`this`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this)
  - [`Function.prototype.call()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
  - [`Function.prototype.bind()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)
  - [`new` operator](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/new)
- [Understanding JavaScript Function Invocation and "this"](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)
- [\[JavaScript\] 화살표 함수와 this 바인딩](https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9)
