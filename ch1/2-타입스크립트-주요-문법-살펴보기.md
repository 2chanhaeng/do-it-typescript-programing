# 타입스크립트 주요 문법 살펴보기

- [타입스크립트 주요 문법 살펴보기](#타입스크립트-주요-문법-살펴보기)
  - [ESNext 주요 문법](#esnext-주요-문법)
    - [구조 분해 할당](#구조-분해-할당)
    - [화살표 함수](#화살표-함수)
    - [클래스](#클래스)
      - [상속](#상속)
    - [모듈](#모듈)
    - [생성자](#생성자)
    - [Promise, async/await](#promise-asyncawait)
  - [참조](#참조)

## ESNext 주요 문법

### 구조 분해 할당

```typescript
const amy = {
  name: 'Amy',
  age: 20,
};
const { name, age } = amy;
console.log(name, age); // Amy 20

let array = [1, 2, 3, 4];
let [head, ...rest] = array;
console.log(head, rest); // 1 [2, 3, 4]

let a = 1, b = 2;
[a, b] = [b, a];
console.log(a, b); // 2 1
```

파이썬도 `*` 연산자를 비슷하게 사용할 수 있다.  
파이썬은 `*` 후에도 다른 변수를 할당할 수 있지만, 아쉽게도 JS는 `...` 를 사용한 이후에는 할당할 수 없다.

```python
a, *b, c = [1, 2, 3, 4, 5]
print(a, b, c) # 1 [2, 3, 4] 5
```

```typescript
let [a, ...b, c] = [1, 2, 3, 4, 5]; // Uncaught SyntaxError: rest element may not have a trailing comma
```

### 화살표 함수

```typescript
function declaratedAdd(a: number, b: number): number {
  return a + b;
}
const arrowedAdd = (a: number, b: number): number => a + b;
```

기존의 `function` 키워드를 이용한 함수 선언/표현식 방식과 달리, 화살표 함수는 `this` 바인딩이 다르다.

```typescript
const doctor = {
  name: 'Doctor',
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  },
  sayHiArrow: () => {
    console.log(`Hi, I'm ${this.name}.`);
  },
};
doctor.sayHi(); // Hi, I'm Doctor.
doctor.sayHiArrow(); // Hi, I'm .
```

런타임이 브라우저 환경이고 strict mode가 아닌 경우, 전역 `this`는 `window` 객체를 가리킨다.  
이 때 `sayHi`는 `this`가 `person`으로 바인딩된다.  
하지만 `sayHiArrow`는 `this`가 바인딩 되지 않는다.  
그러므로 `this`를 참조할 경우 상위 스코프인 전역 객체 `window`를 참조하게 된다.

```typescript
let clara = {
  name: 'Clara',
  sayHi: doctor.sayHi,
  sayHiArrow: doctor.sayHiArrow,
  sayHiArrowInFunction() {
    console.log(`Hi, I'm ${this.name}.`);
    (() => console.log(`Hi, I'm ${this.name}.`))();
  }
};
clara.sayHi(); // Hi, I'm Clara.
clara.sayHiArrow(); // Hi, I'm .
clara.sayHiArrowInFunction();
```

JS에서 `Function` 객체를 `call` 메소드를 통해 호출하면 다음과 같다.

```javascript
function sayHi(hi, im) {
  console.log(`${hi}, ${im} ${this}.`);
}
sayHi.call("Clara", "Hi", "I'm"); // Hi, I'm Clara.
```

`call` 메소드는 첫 번째 인자로 `thisValue`를, 그 이후의 인자로 함수 호출 시의 인자를 받는다.  
`call` 메소드를 사용하지 않고 일반적인 방법으로 함수를 호출하면 `this`는 전역 객체를 참조한다.

```javascript
sayHi("Hi", "I'm"); // Hi, I'm [object Window].
```

`call` 메소드를 사용하지 않고 `this`를 바인딩하려면 `bind` 메소드를 사용한다.  
`bind` 메소드는 `thisValue`를 바인딩한 새로운 함수를 반환한다.

```javascript
const sayHiClara = sayHi.bind("Clara");
sayHiClara("Hi", "I'm"); // Hi, I'm Clara.
```

만약 객체의 메소드를 `bind` 메소드를 통해 바인딩하면, `this`는 바인딩된 객체를 참조한다.

```javascript
const sayHiClara = sayHi.bind(clara);
sayHiClara("Hi", "I'm"); // Hi, I'm Clara.
```

이를 통해 함수 표현식과 화살표 함수를 이용한 메소드 선언 시 `this` 바인딩의 차이를 이해할 수 있다.  
함수 표현식으로 메소드를 선언하면 메소드에 객체를 바인딩한 함수를 할당한 것과 같다.
화살표 함수으로 메소드를 선언하면

```javascript
function sayHi() {
  console.log(`Hi, I'm ${this.name}.`);
}

const rose = {
  name: 'Rose',
  sayHi: sayHi, // 자동으로 객체를 바인딩 해준다.
  sayHiArrow: sayHi.bind(this), // 현재 스코프의 this, 즉 현재 맥락의 rose가 아닌 전역 this를 바인딩한다.
};
// 혹은 다음과 같다.
const rose = { name: 'Rose' };
rose.sayHi = sayHi.bind(rose);
rose.sayHiArrow = sayHi.bind(this);
```

다음과 같은 코드를 실행하면 더 확실히 이해할 수 있다.

```typescript
const outer = {
    name: "outer",
    sayHi: function() {
        const inner = {
            name: "inner",
            sayHiFuncExp: function() {
                console.log(`Hi, I'm ${this.name}.`);
            },
            sayHiNotBinded: sayHi,
            sayHiArrow: () => console.log(`Hi, I'm ${this.name}.`),
            sayHiBinded: sayHi.bind(this),
        };
        console.log("Function Expression & Not Binded: this is inner");
        inner.sayHiFuncExp(); // Hi, I'm inner.
        inner.sayHiNotBinded(); // Hi, I'm inner.
        console.log("Arrow Function & Binded: this is outer");
        inner.sayHiArrow(); // Hi, I'm outer.
        inner.sayHiBinded(); // Hi, I'm outer.
    },
}
outer.sayHi();
```

`sayHiFuncExp`, `sayHiNotBinded`는 `this`에 `inner` 객체가 바인딩된다.  
`sayHiArrow`, `sayHiBinded`는 `this`에 `outer` 객체가 바인딩된다.

### 클래스

많은 객체 지향 언어에서 사용되는 클래스 문법이 ES6에서 도입되었다.

```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  }
}
const yaz = new Person('Yaz', 20);
```

이를 ES5에서도 호환 가능한 다음과 같은 코드로도 작성할 수 있다.

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHi = function() {
    console.log(`Hi, I'm ${this.name}.`);
  }
  return this;
}

const yaz = new Person('Yaz', 20);
```

`new` 연산자는 클래스의 인스턴스를 생성한다.  
만약 해당 코드에서 `new` 연산자가 없다면 `this`는 전역 객체를 참조한다.

```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHi = function() {
    console.log(this);
    console.log(`Hi, I'm ${this.name}.`);
  }
  return this;
}

const withoutNewYaz = Person('Yaz', 20);
withoutNewYaz.sayHi();
// Window
// Hi, I'm Yaz.
const yaz = new Person('Yaz', 20);
yaz.sayHi();
// Person {name: "Yaz", age: 20, sayHi: ƒ}
// Hi, I'm Yaz.
```

클래스 문법을 사용해서 인스턴스를 생성할 때 `new` 연산자가 없다면, 런타임이 이를 막기 때문에 클래스의 인스턴스를 생성할 수 없다.

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
  sayHi() {
    console.log(`Hi, I'm ${this.name}.`);
  }
}
const yaz = new Person('Yaz');
// Person { name: 'Yaz', sayHi: [Function: sayHi] }
const withoutNewYaz = Person('Yaz');
// Uncaught TypeError: class constructors must be invoked with 'new'
```

이제 객체지향 패러다임의 주 특성인 상속, 캡슐화, 다형성, 추상화를 어떻게 구현하는지 알아보자

#### 상속

JS는 `extends` 키워드를 통해 상속을 구현할 수 있다.  
상속을 받는 자손 클래스에서는 `super` 키워드를 통해 부모 클래스의 생성자를 호출할 수 있다.

```javascript
class Companion extends Person {
    constructor(name, end) {
        super(name);
        this.end = end;
    }
    endWith() {
        console.log(`${this.name} ${this.end}.`);
    }
}

const bill = new Companion('Bill', 'became a Cyberman');
bill.sayHi(); // Hi, I'm Bill.
bill.endWith(); // Bill became a Cyberman.
```

자손 클래스의 생성자에서 `super` 키워드를 호출하지 않으면 부모 클래스의 생성자가 호출되지 않는다.  
이로 인해 `this`가 초기화되지 않아 인스턴스 생성 시 오류가 발생한다.

```javascript
class Companion extends Person {
    constructor(name, end) {
        this.end = end;
    }
}

const bill = new Companion('Bill', 'became a Cyberman');
// Uncaught ReferenceError: must call super constructor before using 'this' in derived class constructor
```

### 모듈

### 생성자

### Promise, async/await

## 참조

- [MDN](https://developer.mozilla.org/ko)
  - [`this`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/this)
  - [`Function.prototype.call()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
  - [`Function.prototype.bind()`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)
  - [`new` operator](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/new)
- [Understanding JavaScript Function Invocation and "this"](https://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/)
- [\[JavaScript\] 화살표 함수와 this 바인딩](https://velog.io/@padoling/JavaScript-%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98%EC%99%80-this-%EB%B0%94%EC%9D%B8%EB%94%A9)
